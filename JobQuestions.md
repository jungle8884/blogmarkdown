---
title: JobQuestions
categories:
  - 后端
  - 面经
tags:
  - 面经
author:
  - Jungle
date: 2021-08-16 15:26:09
---

# Java

## 集合

### 介绍一下concurrentHashMap

> ConcurrentHashMap实现原理

- 底层数据结构: jdk1.7 之前底层采用分段数组+链表实现, jdk1.8之后采用的数据结构则是数组+链表/红黑二叉树实现.

- 实现线程安全的方式: 

  - jdk1.7 : 分段锁, 将数据分割分段, 每一段数据分配一把锁, 当一个线程占用了其中一段数据时, 不影响其他数据段被其他线程的访问.

  ![image-20210817153941602](JobQuestions/image-20210817153941602.png)

  - jdk1.8:  **JDK1.8 的时候已经，而取消了分段锁, 采用 `synchronized` 和 CAS 来保证并发安全**, `synchronized`只锁定当前链表或红黑二叉树的首节点, 只要hash不冲突, 就不会产生并发, 效率提升N倍.

    > [CAS](https://www.jianshu.com/p/34a10da2c0d5): compare and swap, 比较并变换.
    >
    > CAS(V, E, N): 若V值等于E值，则将V的值设为N; 若V值和E值不同, 则说明已经有其他线程做了更新, 则当前线程什么都不做.

  ![image-20210817154032680](JobQuestions/image-20210817154032680.png)

### ConcurrentHashmap底层原理和hashmap的区别



### hashmap 1.8删除节点，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)会不会退化为[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)？



### [HashMap和Hashtable的区别](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_141-hashmap-%e5%92%8c-hashtable-%e7%9a%84%e5%8c%ba%e5%88%ab)

1. **线程是否安全：** `HashMap` 是非线程安全的，`HashTable` 是线程安全的,因为 `HashTable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；
2. **效率：** 因为线程安全的问题，`HashMap` 要比 `HashTable` 效率高一点。另外，`HashTable` 基本被淘汰，不要在代码中使用它；
3. **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。
4. **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。
5. **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。



### [HashMap 1.8 怎么实现? 和1.7之前有什么区别? ](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_145-hashmap-%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0)

JDK1.8 之前 `HashMap` 底层是 **数组+链表**。

**HashMap 通过 key 的 hashCode 经过扰动函数(`(h = key.hashCode()) ^ (h >>> 16)`)处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突**

JDK1.8的`HashMap`底层是**数组+链表/红黑树**

HashMap在解决哈希冲突有了较大的变化，**当链表长度大于8且数组的长度大于等于64时，将链表转化为红黑树，以减少搜索时间**(链表转换为红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树)

## JVM

### Java运行时数据区域, 堆是线程公有还是私有, 堆中有线程私有的区域么?

> ![image-20210817195602415](JobQuestions/image-20210817195602415.png)

jdk 1.8之前: **程序计数器, 虚拟机栈**(在 HotSpot 虚拟机中本地方法栈和 Java 虚拟机栈合二为一), **堆**, **方法区(运行时常量池)**

![image-20210817194609186](JobQuestions/image-20210817194609186.png)

jdk 1.8: **程序计数器, 虚拟机栈**(在 HotSpot 虚拟机中本地方法栈和 Java 虚拟机栈合二为一), **堆(字符串常量池)**, **元空间(运行时常量池)**

![image-20210817194626708](JobQuestions/image-20210817194626708.png)

堆中有线程私有的区域吗? (应该是**没有**的)

**线程私有的：**

- 程序计数器
- 虚拟机栈(在 HotSpot 虚拟机中本地方法栈和  虚拟机栈 合二为一)

**线程共享的：**

- **堆**: **所有线程共享的一块内存区域, 几乎所有的对象实例及数组都在这里分配内存.**

- **方法区 (静态变量, 常量, 类信息, 运行时常量池)**: **类的元数据**.

  

### JVM的内存模型中, 哪部分是线程私有的, 为什么?

主要是: **程序计数器** 和 **虚拟机栈**(在 HotSpot 虚拟机中 **本地方法栈** 和  **虚拟机栈** 合二为一), 原因如下:

- 程序计数器: 为了线程切换后能恢复到正确的执行位置, 每条线程都需要有一个独立的程序计数器, 各线程之间互不影响, 独立存储.
- 虚拟机栈: **每次方法调用的数据都是通过栈传递的**, 虚拟机栈由一个个栈帧组成, 每个栈帧包括: **局部变量表**, 操作数栈, 动态链接 和 方法出口信息. (一个方法的执行就是开启了一个线程)

**局部变量表主要存放了编译期可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

### 类加载机制: 加载, 验证, 准备, 解析, 初始化.

- 加载:

  - 获取定义此类的二进制字节流
  - 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表该类的Class对象

- 验证: 

  - 文件格式验证 (Magic Number: **确定这个文件是否为一个能被虚拟机接收的 Class 文件**)

  - 元数据验证: 对字节码描述的信息进行语义分析

  - 字节码验证: 确定程序语义是合法的, 符合逻辑的

  - [符号引用验证](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84?id=_23-%e5%b8%b8%e9%87%8f%e6%b1%a0%ef%bc%88constant-pool%ef%bc%89): 确保解析动作能正确执行

    ![运行时常量池](JobQuestions/image-20210817205618092.png)

- 准备: **正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配.
  - 这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），
  - 比如我们定义了`public static int value=111` ，那么 value 变量在**准备阶段**的初始值就是 0 而不是 111（初始化阶段才会赋值）。
  - 特殊情况：比如给 value 变量**加上了 final 关键字**`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

- 解析: 虚拟机将常量池内的符号引用替换为直接引用的过程。

  - 解析动作主要针对类或接口、
  - 字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

  ![image-20210817210852474](JobQuestions/image-20210817210852474.png)

- 初始化: 初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

  ![image-20210817211051125](JobQuestions/image-20210817211051125.png)

- 解释: 

  - 什么时候初始化
    - new 即 实例化对象的时候
    - getstatic / setstatic 读取或设置静态字段时(static final静态常量除外)
    - invokestatic 调用类静态方法的时候
    - 使用反射Class.forName()进行反射调用的时候
  - 初始化顺序
    - 1 父类的静态变量和静态块赋值 (按声明顺序)
    - 2 自身的静态变量和静态块赋值 (按声明顺序)
    - 3 父类的成员变量和块赋值 (按声明顺序)
    - 4 父类构造器赋值
    - 5 自身的成员变量和块赋值 (按声明顺序)
    - 自身构造器赋值



## GC

### 聊一聊垃圾回收(总结性质的问题)

> [GC历史](https://blog.csdn.net/xiaojin21cen/article/details/106686506)
>
> ![image-20210818161316459](JobQuestions/image-20210818161316459.png)

1. **先说有哪些垃圾收集算法**

垃圾收集算法主要有: 标记-复制(新生代), 标记-整理(老年代), 标记-清除(老年代) 和 分代收集算法.

分代收集算法: 根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

- jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
- jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
- jdk1.9 默认垃圾收集器G1

2. **这些垃圾收集算法的应用**

新生代GC: 

- Serial [标记-复制算法]
- ParNew [标记-复制算法]
- Parallel Scavenge [标记-复制算法] : 关注吞吐量

老年代GC: 

- Serial Old [标记-整理算法]
- ParNew Old [标记-整理算法]
- CMS [标记-清除算法] : 关注响应时间(垃圾收集时用户的停顿时间)

G1---整堆垃圾收集器: 整体上看是[标记-整理算法], 局部上看是[标记-复制算法].

3. **垃圾收集器的适用场景**

[Serial和Serial Old], Serial收集器是所有收集器中额外内存消耗最小的, 所以**适用于内存资源受限的环境**, 如单核CPU或CPU核心数较少的环境(运行在客户端模式下的虚拟机来说是一个很好的选择).

[CMS可以和Serial, ParNew收集器配合工作], CMS**适用于互联网网站或者基于浏览器的B/S系统的服务端上**, 关注服务的响应速度, 希望系统停顿时间尽可能短, 以给用户带来良好的交互体验.

[Parallel Scavenge 和 Serial Old] , Parallel Scavenge 目标是达到一个可控制的吞吐量, 高吞吐量则可以高效率地利用处理器资源, 尽快完成程序的运算任务, **适合在后台运算而不需要太多交互的分析任务**.

G1适用于服务器端.

### 垃圾回收器: CMS, G1

- **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器**

  - **它非常符合在注重用户体验的应用上使用**

  - **是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作**

  - 从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

    ![image-20210818110722824](JobQuestions/image-20210818110722824.png)

    - **初始标记：** 暂停所有的其他线程，并**记录下直接与 GC Roots 相连的对象**，速度很快 ;
    - **并发标记：** **从GC Roots的直接关联对象开始遍历整个对象图的过程,** 这个过程耗时较长但是不需要停顿用户线程, 可以与垃圾收集线程一起并发运行;
    - **重新标记：** 为了**修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段的时间短;
    - **并发清除：** 清理删除掉标记阶段判断的已经死亡的对象, 由于不需要移动存活对象, 所以这个阶段也是可以与用户线程同时并发的.

  - 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

    - **对 CPU 资源敏感；**
    - **无法处理浮动垃圾；**
    - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

- **G1 (Garbage-First) 是一款面向服务器的垃圾收集器**,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征. **(所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值)**
  - 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：
    - **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
    - **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
    - **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
    - **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
  - G1 收集器的运作大致分为以下几个步骤：
    - **初始标记**: **仅仅只是标记一下GC Roots能直接关联到的对象**, 并且修改TAMS(Top at Mark Start)指针的值, 让下一阶段用户线程并发运行时, 能正确地在可用的Region中分配新对象. 这个阶段**需要停顿线程**, 但耗时很短, 而且是借用进行Minor GC的时候同步完成的, 所以G1收集器在这个阶段**实际并没有额外的停顿**.
    - **并发标记**: **从GC Roots开始对堆中对象进行可达性分析, 递归扫描整个堆里面的对象图, 找出要回收的对象**, 这段时间耗时较长, 但可与用户程序并发执行. 当对象图扫描完成以后, 还要重新处理**STAB(原始快照)记录**下的在并发时有引用的对象.
    - **最终标记**: **对用户线程做另一个短暂的暂停, 用于处理并发阶段结束后仍遗留下来的最后那少量的STAB记录**.
    - **筛选回收**: 负责更新Region的统计数据, 对各个Region的回收价值和成本进行排序, 根据用户期望的停顿时间来制定回收计划, 可以自由选择任意多个Region构成回收集, 然后**把决定回收的那一部分Region的存活对象赋值到空的Region中, 再清理掉整个旧Region的全部空间**. 这里的操作涉及存活对象的移动, 是**必须暂停用户线程**, 由多条收集器线程并行完成的. 
  - **G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。
  - G1收集器**除了并发标记以外, 其余阶段也是要完全暂停用户线程的**, 它的目标是在延迟可控的情况下获得尽可能高的吞吐量.

**并行和并发概念补充：**

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。



## 多线程

### ReentrantLock 和 synchronized的区别

> 看文章: https://blog.csdn.net/wangnanwlw/article/details/109243637



### AQS和lock的比较



### CAS原理，ABA问题如何解决



### 线程的状态, 状态转移条件, 创建方式, 和进程的区别



### volatile的作用是什么

- 禁止JVM的指令重排
- 保证变量的可见性 (把变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取)

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **`volatile` 关键字**是线程同步的**轻量级实现**，所以 **`volatile `性能肯定比`synchronized`关键字要好** 。但是 **`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块** 。
- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。**
- **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**



### 介绍一下synchronized的实现

**`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

[JDK1.6 对锁的实现引入了大量的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)，锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。



### 线程池参数有哪些, 具体应该怎么配置 

> [三大方法, 七大参数 和 四大策略](https://blog.csdn.net/kongsanjin/article/details/111218612)
>
> [阿里巴巴开发手册](https://kangroo.gitee.io/ajcg/#/concurrent)
>
> [OOM](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_22-java-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88)
>
> 面试问题:
>
> - 线程池的七大参数，及其工作过程
>
> - 线程池基本参数, 一个线程被提交到线程池的流程

**七大参数:**

- **`corePoolSize` :** 核心线程数线程数定义了**最小可以同时运行的线程数量**。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前**可以同时运行的线程数量变为最大线程数**。
- **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
- **`unit`** : `keepAliveTime` 参数的时间单位。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

- **`threadFactory`** :executor 创建新线程的时候会用到。

- **`handler`** :拒绝策略。关于饱和策略下面单独介绍一下。

**怎么配置:**

> maximumPoolSize(线程池的最大线程数)的设置:
>
> - CPU密集型: (获取CPU的核数)Runtime.getRuntime().availableProcessors();
> - IO密集型: > 程序中十分耗IO的线程数, 一般为2倍



**一个线程被提交到线程池的流程:**

> 工作流程



### 线程池四大拒绝策略

**`ThreadPoolExecutor` 饱和策略定义:**

如果**当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了**时，`ThreadPoolTaskExecutor` 定义一些策略:

- **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`：** **调用执行自己的线程运行任务**，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** **不处理新任务，直接丢弃掉**。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** **此策略将丢弃最早的未处理的任务请求**。



### 经典线程池有哪些？每个的底层原理是什么？

jdbc连接池?

---



## Spring

### spring AOP底层原理



### AOP 代理常用的都有哪些



---

# 算法题

> 二叉树距离最远的两个结点的距离



> 剑指offer04: 二维数组中的查找



>加减乘除求根号2



> 股票问题 



> 数据流中的中位数 (剑指offer) --- 并加入并发锁控制



## 手撕：[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的就地逆置问题



## 手撕：寻找[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的循环节点



## 手撕翻转链表, 括号匹配



## 二叉树后续遍历展开为链表 (用栈迭代)

> 能不用栈么 (输出链表模拟栈)
>
> 还能更省空间么---morris原地展开二叉树



> 几个大文件怎么排序 (归并)



> 给定一个自然数数组, 找出里面所有和为N的组合



> 给定一个正整数数组, 把奇数排右边, 偶数排左边, 相对顺序不能变



> 堆排序



> 最长不重复子串



## 链表反转



> 带重复的有序数组找第一个等于目标值的数的下标



> 摩尔投票



---

# 数据结构

> B树和B+树的区别



> 了解LSM树么?



---

# 设计模式

> 设计模式知道哪些, 手写单例模式



---

# 计算机网络

> 输出一个url发生了什么



> Tcp三次握手，四次挥手，过程及原因



> DNS域名解析使用那个传输层协议, 解析后得到的IP地址属于网络模型中的哪一层?



>http 握手机制, 缓存机制



> udp使用场景



> 网络七层模型, 应用层有什么协议, 网络层有什么协议, 传输层有什么协议, TCP/UDP区别



> HTTP与WebSocket区别



> TCP流量控制



> TCP怎么缩小发送方窗口



> SSL的握手过程



> SSL为什么要用对称和非对称两种加密, 只用非对称有什么问题



> SSL数字证书CA有什么用



---

# 数据库

## mysql中行锁，表锁，及使用情况



## mysql四大隔离级别



## 脏读，幻读，不可重复读



> 讲讲索引



> MySql索引的存储方式



> 为什么用B+树存储索引



> 为什么非叶子结点只存储索引值



> 一条慢查询语句, 怎么优化它



> MySQL索引的底层数据结构



> 介绍一下MySQL事务



> MySQL语句调优



> 数据库索引数据结构有哪几种, 分别有哪些优势



---

# Linux常用命令



---

# Docker常用命令



---

# 操作系统

> 页面置换算法



---

# 项目

> 说一下你对rpc和api的理解, 讲讲区别



> 谈谈ioc与aop并说明一下两者都有哪些使用场景



> 介绍一下项目的事务一致性, 是实现PRC调用的, 有没有做主从服务, 容灾



---

# 其他



> 单例模式, 排序算法, 生产者和消费者, 死锁
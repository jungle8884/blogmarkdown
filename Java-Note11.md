---
title: Java-Note11
categories:
  - Java
tags:
  - 权限修饰符
  - final
  - 内部类
  - 匿名内部类
date: 2020-10-10 09:50:47
author: Jungle

---
# final #

**final关键字代表最终, 不可改变的.**

常见四种用法:

1. 可以用来修饰一个类
2. 可以用来修饰一个方法
3. 还可以用来修饰一个局部变量
4. 也可以用来修饰一个成员变量

## 修饰一个类 ##

当final关键字修饰一个类的时候

- 格式:

		public final class 类名称 {
			// ...
		}

- 含义: 当前这个类不能有任何的子类.
- 注意: 如果一个类是final的, 那么其中所有的成员方法都无法进行覆盖重写.

## 修饰一个方法 ##

当final关键字用来修饰一个方法的时候, 这个方法就是最终方法, 也就是不能被覆盖重写.

- 格式:

		修饰符 final 返回值类型 方法名称(参数列表) {
			// ...
		}

- 注意: 对于类、方法来说,  abstract关键字和final关键字不能同时使用, 因为矛盾.

## 修饰一个局部变量 ##

一旦使用了final用来修饰局部变量, 那么这个变量就不能进行更改.

- **"一次赋值, 终身不变"**
- 只要保证有唯一一次赋值即可, 不一定非得在声明时赋值.
- **不可变:**
	- 对于基本类型来说, 不可变说的是变量当中的数据不可改变.
	- 对于引用类型来说, 不可变说的是变量
		- 当中的地址值不可改变;
		- 但是, 其中的内容可以改变.

## 修饰成员变量 ##

**对于成员变量来说, 如果使用final关键字修饰, 那么这个变量也照样是不可变.**

1. 由于成员变量具有默认值, 所以用了final关键字之后必须手动赋值, 不会再给默认值.
2. 对于final成员变量, 要么使用直接赋值[声明后赋值], 要么通过构造方法赋值. [**二者选其一**]
3. 必须保证类当中所有的重载的构造方法, 都最终会对final的成员变量进行赋值.

----------
# Java中的四种权限修饰符 #

							public 	> 	protected	 > 	(default)	 > 	private
	
	同一个类(我自己)			YES			YES				YES				YES
	同一个包(我邻居)			YES			YES				YES				NO
	不同包子类(我儿子) 		   YES		    YES				NO				NO
	不同包非子类(陌生人)		   YES			NO				NO				NO

**注意事项: (default) 并不是关键字"default", 而是根本不写.**

----------
# 内部类 #

```
如果一个事物的内部包含另一个事物, 那么这就是一个类内部包含另一个类.
```

## 分类:

1. 成员内部类
2. 局部内部类(包含匿名内部类)

## 成员内部类 ##

- 定义格式:

		修饰符 class 外部类名称 {
			修饰符 class 内部类名称 {
				// ...
			}
			// ...
		}

- 注意: 
	- 内用外, 随意访问;
	- 外用内, 需要借助内部类对象.
- 如何使用成员内部类? 有两种方式:
	- 间接方式: 
		- 在外部类的方法当中, 使用内部类;
		- 然后在main只是调用外部类的方法.
	- 直接方式:
		- 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
		- 直接通过创建的对象进行调用.
- 如果出现了重名现象, 如何访问外部类的成员变量. 那么格式是: 
	
	- 外部类名称.this.外部类成员变量名

##  局部内部类 ##

```
如果一个类是定义在一个方法内部的, 那么这就是一个局部内部类.
```



- 局部: 只有当前所属的方法才能使用它, 出了这个方法外面就不能用了.
- 定义格式:

		修饰符 class 外部类名称 {
			修饰符 返回值类型 外部类方法名称(参数列表) {
				class 局部内部类名称 {
					// ...
				}
			}
		}

- 小结: 
	- 权限修饰符: public > protected > (default) > private
	- 定义一个类的时候, 权限修饰符规则:
		1. 外部类: public / (default)
		2. 成员内部类: public / protected / (default) / private
		3. 局部内部类: 什么都不能写

- 局部内部类, 如果希望访问所在方法的局部变量, 那么这个局部变量必须是 **有效final的**.
	- 备注: 从Java 8+开始, 只要局部变量事实不变, 那么final关键字可以省略.
	- **有效final的**: 事实上局部变量的值不发生改变.
	- 原因:
		1. new 出来的对象在堆内存中;
		2. 局部变量是跟着方法走的, 在栈内存当中;
		3. 方法运行结束之后, 立刻出栈, 局部变量就会立刻消失;
		4. 但是new出来的对象会在堆中持续存在, 直到垃圾回收消失.
	- 理解: 
		- 为了解决生命周期的问题, 
		- 在局部内部类当中, 会将局部变量的值copy一份, 当作常量, 
		- 当它消失后依然可以使用,
		- 留下的东西不变即可.

## 匿名内部类 ##

```
如果接口的实现类 (或是父类的子类) 只需要使用唯一的一次,
那么这种情况下就可以省略掉该类的定义, 而改为使用 匿名内部类.			
```



- 定义格式:

		接口名称 对象名 = new 接口名称() {
			// 覆盖重写所有抽象方法
		};

- 对格式 **new 接口名称() {...}** 进行解析:
	1. new 代表创建对象的动作
	2. 接口名称 就是匿名内部类需要实现哪个接口
	3. {...} 这才是匿名内部类
- 注意事项:
	1. 匿名内部类, 在 **创建对象** 的时候, 只能使用唯一一次. 如果希望多次创建对象, 而且类的内容一样的话, 那么就必须使用单独定义的实现类了.
	2. 匿名对象, 在 **调用方法** 的时候, 只能调用唯一一次. 如果希望同一个对象, 调用多次方法, 那么必须给对象起个名字.
	3. 匿名内部类是省略了 **实现类/子类名称**, 但是匿名对象是省略了 **对象名称**.
	4. 强调: **匿名内部类和匿名对象不是一回事!!!**

----------

---
title: Java-Note7
categories:
  - Java
tags:
  - 类
  - 封装
  - 继承
  - 多态
date: 2020-09-09 09:55:39
author: Jungle

---
# 类 #
是一组相关属性和行为的集合。可以看成一类事物的模板，使用事物的属性特征和行为来描述该类事物。

如果没有编写任何构造方法，那么编译器会默认赠送一个构造方法，没有参数，方法体什么事情也不做；
**一旦编写了至少一个构造方法，那么编译器将不再赠送。**

## 定义一个标准的类【也叫：Java Bean】 ##
1. 所有的成员变量都要使用private关键字修饰
2. 为每一个成员变量编写一对儿Getter/Setter方法
3. 编写一个无参数的构造方法
4. 编写一个全参数的构造方法

## 属性 和 字段 ##
成员变量是直接定义在类当中的，在方法外边。

## 方法 ##
成员方法不要写static关键字

## this ##
this.成员变量名

## 默认访问级别 ##
- C#:	
	- 类, 命名空间：			internal 
	- 类成员(域, 属性, 方法) 以及 结构类型：	private
	- 枚举类型以及接口类型: 	默认为public且只能为public(即使写也默认是public的)
- Java:	(default 即 不带任何修饰符)
	- public > protected > (default) > private
	- 注: (default) 不是关键字, 而是声明时不写权限修饰符, 留空. 
	- 具体看Java-Note11

## 可访问性 ##
1. C#
	- 类的可访问性： public 和 internal
	- 成员的可访问性： 
		1. public：所有的类，包括程序集内部的类和外部的类都可以自由地访问成员。
		2. private：只能被它自己的类的成员访问。
		3. protected：允许派生自该类的类访问该成员，即使程序集外部继承该类的类也能访问该成员。
		4. internal：对当前程序集内部的所有类可见，但对程序集外部的类不可见。
		5. protected internal：对所有继承该类的类 或 所有程序集内部的类可见。
2. Java [**不论什么权限修饰符, 同一个类当然都可以访问!**]
	- public: 
		- 全部包的任何类.
		- 被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。
	- protected: 
		- 同一个类, **同一个包中** 和 **不同包的子类** 可以访问.
		- 被其修饰的类、属性以及方法**只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。**
	- default: 
		- 同一个类 和 **同一个包中** 可以访问
		- 即不加任何访问修饰符，通常称为“默认访问模式“。
		- 该模式下，只允许在同一个包中进行访问。
	- private: 
		- 同一个类中 可以访问. 
		- 被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。

## 命名风格  ##
1. Pascal大小写：标识符中每个单词的首字母大写。					**类型名称和类中对外可见成员的名称【类，方法，命名空间，属性 和 公共字段】**
2. Camel大小写：标识符中每个单词的首字母大写，第一个单词除外。	**局部变量的名称和方法声明的形参名称**
3. 下划线加Camel大小写：以下划线开头的Camel大小写的标识符。		**私有或受保护的字段**

**通过谁调用的方法，谁就是this。**
----------

# 对象 #
是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。

## 对象的创建及其使用 ##
通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。

1. 导包：也就是指出需要使用的类，在什么位置。 

	- import 包名称.类名称;
	- 对于和当前类属于同一个包的情况，可以省略导包语句不写。

2. 创建

	- 格式： 类名称 对象名 = new 类名称();

3. 使用

	- 使用成员变量：	对象名.成员变量
	- 使用成员方法： 对象名.成员方法名(参数列表)

## 对象的内存图 ##
分为栈，堆，方法区。

当一个对象作为参数传递到方法中时，实际上传递进去的是对象的地址值。


----------

# 类和对象的关系 #
- 类是对一类事物的描述，是抽象的。
- 对象是一类事物的实例，是具体的。
- 类是对象的模板，对象是类的实体。

----------

# 类中成员变量与局部变量 #

1. 定义的位置不一样
	- 局部变量： 在方法的内部
	- 成员变量： 在方法的外部，直接写在类当中
2. 作用的范围不一样
	- 局部变量： 只有方法当中才可以使用，出了方法就不能再用
	- 成员变量： 整个类全都可以通用
3. 默认值不一样
	- 局部变量： 没有默认值， 如果要想使用，必须手动进行赋值
	- 成员变量： 如果没有赋值，会有默认值，规则和数组一样。

----------
# 面向对象三大特征 #

## 封装 ##
封装就是将一些细节信息隐藏起来，对于外界不可见。

1. 方法就是一种封装
2. 关键字private也是一种封装
		
		一旦使用了private进行修饰，那么本类当中仍然可以随意访问； 但是，超出了本类范围之外就不能再直接访问了。		

		间接访问private成员变量，就是定义一对儿Getter/Setter方法

		必须叫setXXX或者是getXXX命名规则。
			对于Getter来说，不能有参数，返回值类型和成员变量对应；
			对于Setter来说，不能有返回值，参数类型和成员变量对应。
		对于boolean类型，get对应isXXX()方法。

----------
## 继承 ##
继承时多态的前提, 如果没有继承, 就没有多态.

- 继承主要解决的问题就是: **共性抽取**
	- 父类: 也叫 基类, 超类
	- 之类: 也叫 派生类
- 继承关系当中的特点:
	- 子类可以拥有父类的"内容" 
		- "子类就是一个父类": 子类可以被当作父类看待.
		- 例如: 
			- 父类: Country 
			- 子类: China 
			- [ 'China' is a 'Country'.]
	- 子类还可以拥有自己专有的内容

**定义格式**

- 定义父类: 
	
	public class 父类名称 {
		// ...
	}

- 定义子类:
	
	public class 子类名称 extends 父类名称 {
		// ...
	}

**在父子类的继承关系当中, 如果成员变量重名, 则创建子类对象时, 访问有两种方式:**

1. 直接通过子类对象访问成员变量:
	- 等号左边是谁 [对象声明赋值时], 就优先用谁, 没有则向上找.
2. 间接通过成员方法访问成员变量:
	- 该方法属于谁 [在谁那里定义的], 就优先用谁, 没有则向上找.
3. 注:
	- 局部变量:			直接写成员变量名
	- 本类的成员变量:	this.成员变量名
	- 父类的成员变量:	**super.成员变量名 [C#中用: base.成员变量名]**


**在父子类的继承关系当中, 创建子类对象, 访问成员方法的规则:**

- 创建的对象是谁, 就优先用谁, 如果没有, 则向上找.


**注意事项: 无论是成员方法还是成员变量, 如果没有都是向上找父类, 绝对不会向下找子类.**


**重写 [Override]**

- 概念:  在继承关系当中, 方法的名称一样, 参数列表也一样.

- 覆盖重写[**Override**]: 	方法的名称一样, 参数列表[**也一样**].   
	- 也叫: **覆写**.
	- **方法的覆盖重写特点:	创建的是子类对象, 则优先用子类方法.**
- 重载[Overload]: 		方法的名称一样, 参数列表[**不一样**].

- 方法覆写的注意事项:
	1. 必须保证父子类之间方法的名称相同, 参数列表也相同.
		- @Override: 写在方法前面, 用来检测是不是有效的正确覆盖重写.
		- @: 表示 Anotation 注解
		- 这个注解就算不写, 只要满足要求, 也是正确的方法覆盖重写.
	2. 子类方法的返回值必须**小于等于**父类方法的**返回值范围**.	
		- 比如:
			- java.lang.Object 所有类的公共最高父类
			- java.lang.String 就是Object的子类
	3. 子类方法的权限必须大于等于父类方法的权限修饰符.
		- public > protected > (default) > private
		- 注: (default) 不是关键字, 而是声明时不写权限修饰符, 留空. 

- 设计原则:
	- 对于以及投入使用的类, 尽量不要进行修改.
	- 推荐定义一个新的类, 来重复利用其中共性内容, 并且添加改动新内容.
	- 继承就体现了这个原则.

- 继承关系中, 父子类构造方法的访问特点:
	1. 子类构造方法当中有一个默认隐含的"super()"调用, 所以一定是先调用的父类构造, 后执行子类构造.
	2. 子类构造可以通过super关键字来调用父类重载构造.
	3. **super的父类构造调用, 必须是子类构造方法的第一个语句.** 
	4. **子类必须调用父类构造方法, 不写则赠送super();**
	5. 写了则用指定的super调用对应父类构造, super只能有一个, 还必须是第一个.

**super关键字用来访问父类内容, 而this关键字用来访问本类内容.**

- super 关键字的用法有三种:
	1. 在子类的成员方法中, 访问父类的成员变量.
	2. 在子类的成员方法中, 访问父类的成员方法.
	3. 在子类的构造方法当中, 访问父类的构造方法.
- this 关键字的三种用法: 
	1. 在本类的成员方法中, 访问本类的成员变量.
	2. 在本类的成员方法中, 访问本类的另一个成员方法.
	3. 在本类的构造方法中, **访问本类的另一个构造方法.**
		- 注: 
			- this(...)调用也必须是构造方法的第一个语句, 唯一一个. [**同时, super() 将不再赠送.**]
			- super 和 this 两种构造调用, 不能同时使用.

**Java语言是单继承的.**

- 一个类的直接父类只能有唯一一个.


**Java可以多级继承.** 

- 类C 继承自 类B, 类B 继承自 类A.
- A <-- B <-- C

**一个子类的直接父类是唯一的, 但是一个父类可以拥有很多个子类.**

- 类B 继承自 类A, 类C 也继承自 类A.
- A <-- B,  A <-- C.

----------
## 多态 ##
**extends 继承 或者 implements 实现, 是多态性的前提.**

**代码当中体现多态性, 其实就是一句话: 父类引用指向子类对象.**

**左父右子**

**格式:**
	
		父类名称 对象名 = new 子类名称();
	或者
		接口名称 对象名 = new 实现类名称();

**访问成员变量的两种方式:**

1. 直接通过对象名称访问成员变量: 看等号左边是谁, 就优先用谁, 没有则向上找. [ **成员变量不会覆盖重写, 成员方法才会覆盖重写** ]
2. 间接通过成员方法访问成员变量: 看方法属于谁, 就优先用谁, 没有则向上找. [ **方法是动态绑定的**, 除了有修饰符static和final的. ]
3. 口诀: 
	- 成员变量: 		**一直看左边**
	- **成员方法**: 	**编译看左边, 运行看右边**


**对象的向上转型**

- 格式: 父类名称 对象名 = new 子类名称();
- 含义: 右侧创建一个子类对象, 把它当做父类来看待使用.
- 举例:

		Animal animal = new Cat();
		创建了一只猫, 当做动物来看待, 没问题.
- **注意事项**: **向上转型一定是安全的.** [从小范围转向了大范围]

**对象的向下转型**

- 向上转型也有一个弊端: 对象一旦向上转型为父类, 那么就无法调用子类原本特有的内容.
- 解决方案: 用对象的向下转型 [**其实是一个还原的动作**]
- 格式: 子类名称 对象名 = (子类名称)父类对象;
- 含义: 将父类对象,  **还原** 成为 **本来** 的子类对象.
- 举例:

		Animal animal = new Cat(); //本来是猫, 向上转型为动物
		Cat cat = (Cat) animal; //本来是猫, 已经被当做动物了, 还原回来成为本来的猫.

- **注意事项**: 
	- **必须保证对象本来创建的时候, 就是猫, 才能向下转型成为猫.**
	- 如果对象创建的时候本来不是猫, 现在非要向下转型成为猫, 就会报错.


**如何才能知道一个父类引用的对象, 本来是什么子类?**

- 向下转型一定要进行判断.
- 格式:

		对象 instanceof 类名称

- 这将会得到一个 boolean 值结果, 也就是判断**前面的对象**能不能当做**后面类型**的实例.
- 应用:

		if (animal instanceof Cat) { //判断一下父类引用animal本来是不是Cat.
			Cat cat = (Cat) animal;
			cat.成员方法;
		}

----------
## 笔记本接口实例 ##

- 接口

		package PCIUSB;
		
		public interface USB {
		
		    //打开设备
		    public abstract void open();
		
		    //关闭设备
		    public abstract void close();
		}

- 实现类
	1. Mouse

			package PCIUSB;
			
			
			public class Mouse implements USB {
			    @Override
			    public void open() {
			        System.out.println("打开鼠标");
			    }
			
			    @Override
			    public void close() {
			        System.out.println("关闭鼠标");
			    }
			
			    public void click() {
			        System.out.println("鼠标点击");
			    }
			}

	2. Keyboard

			package PCIUSB;
			
			public class Keyboard implements USB {
			    @Override
			    public void open() {
			        System.out.println("打开键盘");
			    }
			
			    @Override
			    public void close() {
			        System.out.println("关闭键盘");
			    }
			
			    public void type() {
			        System.out.println("键盘输入");
			    }
			}

	3. Computer

			package PCIUSB;
			
			public class Computer {
			
			    public void powerOn() {
			        System.out.println("笔记本电脑开机");
			    }
			
			    public void powerOff() {
			        System.out.println("笔记本电脑关机");
			    }
			
			    //使用USB设备的方法, 使用接口作为方法的参数
			    public void useDevice(USB usb) {
			        usb.open();
			        if(usb instanceof Mouse){
			            //((Mouse) usb).click();
			            Mouse mouse = (Mouse) usb;
			            mouse.click();
			        } else if (usb instanceof Keyboard) {
			            Keyboard keyboard = (Keyboard) usb;
			            keyboard.type();
			        }
			        usb.close();
			    }
			
			}

- Main()

		package PCIUSB;
		
		public class DemoMain {
		    public static void main(String[] args) {
		        Computer computer = new Computer();
		        computer.powerOn();
		
		        Mouse mouse = new Mouse();
		        Keyboard keyboard = new Keyboard();
		
		        //向上转型
		        USB usbMouse = mouse; //多态写法
		        computer.useDevice(usbMouse);
		
		        //自动向上转型: 从小范围到大范围
		        computer.useDevice(keyboard); //实现类 --> 接口
		
		        computer.powerOff();
		    }
		}
- 注意事项: **实现类可以自动向上转型为接口**.


- 输出结果

		笔记本电脑开机
		打开鼠标
		鼠标点击
		关闭鼠标
		打开键盘
		键盘输入
		关闭键盘
		笔记本电脑关机
		
		Process finished with exit code 0

----------
